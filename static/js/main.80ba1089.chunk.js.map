{"version":3,"sources":["App.tsx","drawGrid.tsx","reportWebVitals.ts","index.tsx"],"names":["grid","head","food","GRID_SIZE","fillOneCell","cell","color","y","x","possibleKeypress","keyPress","tail","score","App","useState","moveTime","setMoveTime","refreshGrid","setRefreshGrid","animation","setAnimation","start","gameOver","gameOptions","setGameOptions","useEffect","document","body","addEventListener","e","pressedKey","key","forEach","direction","positionCheck","moveTail","moveHead","interval","setInterval","clearInterval","t","dir","push","addNewFruit","_","showAnimation","shift","setTimeout","className","type","onClick","map","element","el","style","width","height","id","size","gridArr","gridArr2d","i","j","drawGrid","splice","length","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.80ba1089.chunk.js","sourcesContent":["import React, {useState, useEffect} from 'react';\nimport * as _ from 'lodash';\nimport './App.css';\nimport 'flexboxgrid';\nimport {drawGrid, Grid, CellColor, Cell, Direction} from './drawGrid';\n\nconst GRID_SIZE = 22;\nlet grid: Grid[][];\n\nconst fillOneCell = (cell: Cell, color: CellColor) => {\n  grid[cell.y][cell.x].cell = color;\n};\nconst possibleKeypress: Direction[] = ['ArrowUp', 'ArrowRight', 'ArrowLeft', 'ArrowDown'];\nlet head: Cell;\nlet food: Cell;\nlet keyPress = '';\nconst tail: Cell[] = [];\nlet score = 0;\n\n// fillOneCell(head, 'snake');\n// tail.forEach((t) => fillOneCell(t, 'tail'));\n// fillOneCell(food, 'food');\n\nconst App = () => {\n  // const [head, setHead] = useState<Cell>({x: 2, y: 0});\n  // const [food, setFood] = useState<Cell>({x: _.random(9), y: _.random(9)});\n  // const [tail, setTail] = useState<Cell[]>([\n  //   {x: 0, y: 0},\n  //   {x: 1, y: 0},\n  // ]);\n  // ]);\n  // const [score, setScore] = useState(0);\n  const [moveTime, setMoveTime] = useState(200);\n  const [refreshGrid, setRefreshGrid] = useState(true);\n  const [animation, setAnimation] = useState(false);\n  const [gameOptions, setGameOptions] = useState({start: false, gameOver: false});\n  // const [keyPress, setKeyPress] = useState('');\n  // const [direction, setDirection] = useState<Direction>('ArrowRight');\n\n  const startGame = () => {\n    setGameOptions({...gameOptions, start: true});\n    grid = drawGrid(GRID_SIZE);\n    keyPress = 'ArrowRight';\n    head = {x: 2, y: 0};\n    tail.splice(0, tail.length);\n    tail.push({x: 0, y: 0});\n    tail.push({x: 1, y: 0});\n    food = {x: _.random(GRID_SIZE - 1), y: _.random(GRID_SIZE - 1)};\n    fillOneCell(head, 'snake');\n    tail.forEach((t) => fillOneCell(t, 'tail'));\n    fillOneCell(food, 'food');\n    setRefreshGrid(!refreshGrid);\n  };\n\n  const keyPressHandler = (pressedKey: string) => {\n    possibleKeypress.forEach((direction) => {\n      if (pressedKey === direction) {\n        if (pressedKey === 'ArrowLeft' && keyPress === 'ArrowRight') {\n          return;\n        }\n        if (pressedKey === 'ArrowRight' && keyPress === 'ArrowLeft') {\n          return;\n        }\n        if (pressedKey === 'ArrowDown' && keyPress === 'ArrowUp') {\n          return;\n        }\n        if (pressedKey === 'ArrowUp' && keyPress === 'ArrowDown') {\n          return;\n        }\n        keyPress = pressedKey;\n      }\n    });\n  };\n\n  useEffect(() => {\n    document.body.addEventListener('keydown', (e) => {\n      keyPressHandler(e.key);\n    });\n  }, []);\n\n  useEffect(() => {\n    if (!gameOptions.start) {\n      return;\n    }\n    positionCheck();\n\n    moveTail();\n    moveHead(keyPress);\n    const interval = setInterval(() => {\n      setRefreshGrid(!refreshGrid);\n    }, moveTime);\n    // eslint-disable-next-line consistent-return\n    return () => clearInterval(interval);\n  }, [refreshGrid]);\n\n  const positionCheck = () => {\n    tail.forEach((t) => {\n      if (t.x === head.x && t.y === head.y) {\n        setGameOptions({start: false, gameOver: true});\n      }\n    });\n  };\n\n  const moveHead = (dir: string) => {\n    switch (dir) {\n      case 'ArrowRight':\n        if (head.x === GRID_SIZE - 1) {\n          head = {x: 0, y: head.y};\n        } else {\n          head = {x: head.x + 1, y: head.y};\n        }\n        fillOneCell({x: head.x, y: head.y}, 'snake');\n        break;\n\n      case 'ArrowDown':\n        if (head.y === GRID_SIZE - 1) {\n          head = {x: head.x, y: 0};\n        } else {\n          head = {x: head.x, y: head.y + 1};\n        }\n        fillOneCell({x: head.x, y: head.y}, 'snake');\n        break;\n\n      case 'ArrowLeft':\n        if (head.x === 0) {\n          head = {x: GRID_SIZE - 1, y: head.y};\n        } else {\n          head = {x: head.x - 1, y: head.y};\n        }\n        fillOneCell({x: head.x, y: head.y}, 'snake');\n        break;\n      case 'ArrowUp':\n        if (head.y === 0) {\n          head = {x: head.x, y: GRID_SIZE - 1};\n        } else {\n          head = {x: head.x, y: head.y - 1};\n        }\n        fillOneCell({x: head.x, y: head.y}, 'snake');\n        break;\n    }\n  };\n\n  const moveTail = () => {\n    tail.push({x: head.x, y: head.y});\n    fillOneCell(tail[0], 'empty');\n    addNewFruit();\n    tail.forEach((t) => fillOneCell(t, 'tail'));\n  };\n\n  const addNewFruit = () => {\n    if (head.x === food.x && head.y === food.y) {\n      if (score % 5 === 0) {\n        setMoveTime(moveTime - 10);\n      }\n      score += 1;\n      food = {x: _.random(GRID_SIZE - 1), y: _.random(GRID_SIZE - 1)};\n      fillOneCell(food, 'food');\n      showAnimation();\n    } else {\n      tail.shift();\n    }\n    tail.forEach((t) => {\n      if (t.x === food.x && t.y === food.y) {\n        food = {x: _.random(GRID_SIZE - 1), y: _.random(GRID_SIZE - 1)};\n        fillOneCell(food, 'food');\n      }\n    });\n  };\n\n  const showAnimation = () => {\n    if (score === 0) {\n      return;\n    }\n    if (score % 5) {\n      return;\n    }\n    setAnimation(true);\n    setTimeout(() => {\n      setAnimation(false);\n    }, 4000);\n  };\n\n  return (\n    <div>\n      <div className=\"container center-xs\">\n        <h1 className=\"heading\"> snake snake snake snake snake snake</h1>\n        <span className=\"score\"> {score} points</span>\n        <div className=\"row center-xs game-wrapper\">\n          <div className=\"col-xs-12\">\n            <div className=\"game\">\n              {gameOptions.gameOver && (\n                <button\n                  type=\"button\"\n                  className=\"button button--gameOver\"\n                  onClick={() => {\n                    setGameOptions({start: false, gameOver: false});\n                  }}\n                >\n                  {' '}\n                  <span className=\"score\"> Congratz, you got {score} points! </span>\n                  Play Again!\n                </button>\n              )}\n              {!gameOptions.start ? (\n                <button type=\"button\" className=\"button\" onClick={() => startGame()}>\n                  {' '}\n                  start\n                </button>\n              ) : (\n                <>\n                  {animation && (\n                    <div className=\"animation\">\n                      <h1>LEVEL UP</h1>\n                      <h1>SPEED +10</h1>\n                    </div>\n                  )}\n                  {grid &&\n                    grid.map((element) =>\n                      element.map((el) => (\n                        <span\n                          className={el.cell}\n                          key={el.id}\n                          style={{width: `${800 / GRID_SIZE}px`, height: `${800 / GRID_SIZE}px`}}\n                        >\n                          {/* {el.id} */}\n                        </span>\n                      ))\n                    )}\n                </>\n              )}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default App;\n","export type CellColor = 'empty' | 'snake' | 'food' | 'tail';\r\nexport type Direction = 'ArrowUp' | 'ArrowRight' | 'ArrowLeft' | 'ArrowDown';\r\nexport type Cell = {x: number; y: number};\r\nexport type Grid = {id: number; cell: CellColor};\r\n\r\nexport const drawGrid = (size: number): Grid[][] => {\r\n  let gridArr: Grid[] = [];\r\n  const gridArr2d: Grid[][] = [];\r\n  let id = 1;\r\n  for (let i = 0; i < size; i++) {\r\n    for (let j = 0; j < size; j++) {\r\n      gridArr.push({id, cell: 'empty'});\r\n      id += 1;\r\n    }\r\n    gridArr2d.push(gridArr);\r\n    gridArr = [];\r\n  }\r\n  return gridArr2d;\r\n};\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);  \n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}